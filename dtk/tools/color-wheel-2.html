<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Adobe-Style Color Wheel</title>
<style>
  :root {
    --adobe-blue: #1473e6;
    --adobe-dark: #2c2c2c;
    --adobe-light: #f5f5f5;
    --adobe-border: #d1d1d1;
  }
  
  body {
    font-family: 'Source Sans Pro', 'Segoe UI', sans-serif;
    background: var(--adobe-light);
    color: #333;
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    min-height: 100vh;
  }
  
  header {
    background: white;
    padding: 12px 20px;
    border-bottom: 1px solid var(--adobe-border);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .logo {
    font-weight: 600;
    color: var(--adobe-blue);
    font-size: 18px;
  }
  
  .main-container {
    display: flex;
    flex: 1;
  }
  
  .tool-panel {
    width: 300px;
    background: white;
    border-right: 1px solid var(--adobe-border);
    padding: 20px;
  }
  
  .content-area {
    flex: 1;
    padding: 30px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  
  .color-wheel-container {
    position: relative;
    margin-bottom: 30px;
  }
  
  #wheel {
    border-radius: 50%;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  }
  
  .color-marker {
    position: absolute;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: 3px solid white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    transform: translate(-12px, -12px);
    cursor: pointer;
  }
  
  .harmony-controls {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
  }
  
  .harmony-btn {
    padding: 8px 12px;
    background: white;
    border: 1px solid var(--adobe-border);
    border-radius: 4px;
    cursor: pointer;
    font-size: 13px;
  }
  
  .harmony-btn.active {
    background: var(--adobe-blue);
    color: white;
    border-color: var(--adobe-blue);
  }
  
  .color-palette {
    display: flex;
    width: 100%;
    max-width: 600px;
    margin-top: 30px;
  }
  
  .color-swatch {
    flex: 1;
    height: 120px;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    padding: 10px;
    position: relative;
  }
  
  .color-swatch:first-child {
    border-top-left-radius: 6px;
    border-bottom-left-radius: 6px;
  }
  
  .color-swatch:last-child {
    border-top-right-radius: 6px;
    border-bottom-right-radius: 6px;
  }
  
  .color-value {
    background: rgba(0,0,0,0.6);
    color: white;
    padding: 6px 8px;
    border-radius: 3px;
    font-size: 12px;
    font-family: monospace;
    text-align: center;
  }
  
  .color-swatch-label {
    position: absolute;
    top: 10px;
    left: 10px;
    background: white;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 11px;
    font-weight: bold;
  }
  
  .form-group {
    margin-bottom: 15px;
  }
  
  label {
    display: block;
    margin-bottom: 5px;
    font-size: 13px;
    font-weight: 600;
  }
  
  select, input[type="text"] {
    width: 100%;
    padding: 8px;
    border: 1px solid var(--adobe-border);
    border-radius: 4px;
    font-size: 13px;
  }
  
  .color-mode-selector {
    display: flex;
    border: 1px solid var(--adobe-border);
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 15px;
  }
  
  .mode-btn {
    flex: 1;
    padding: 8px;
    text-align: center;
    cursor: pointer;
    font-size: 13px;
    background: white;
    border: none;
  }
  
  .mode-btn.active {
    background: var(--adobe-blue);
    color: white;
  }
  
  .color-inputs {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
  }
  
  .color-input {
    display: flex;
    align-items: center;
  }
  
  .color-input label {
    width: 30px;
    margin-bottom: 0;
  }
  
  .color-input input {
    flex: 1;
    padding: 6px;
    border: 1px solid var(--adobe-border);
    border-radius: 4px;
  }
  
  .actions {
    margin-top: 20px;
  }
  
  .btn {
    padding: 8px 16px;
    background: var(--adobe-blue);
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 13px;
  }
  
  .btn-outline {
    background: white;
    border: 1px solid var(--adobe-border);
    color: #333;
  }
</style>
</head>
<body>
  <header>
    <div class="logo">Color Wheel</div>
    <div>
      <button class="btn-outline">Save</button>
    </div>
  </header>
  
  <div class="main-container">
    <div class="tool-panel">
      <div class="color-mode-selector">
        <button class="mode-btn active">Color Wheel</button>
        <button class="mode-btn">Color Sliders</button>
      </div>
      
      <div class="form-group">
        <label>Color Harmony</label>
        <div class="harmony-controls">
          <button class="harmony-btn active" data-theory="analogous">Analogous</button>
          <button class="harmony-btn" data-theory="monochromatic">Monochromatic</button>
          <button class="harmony-btn" data-theory="triadic">Triadic</button>
          <button class="harmony-btn" data-theory="complementary">Complementary</button>
          <button class="harmony-btn" data-theory="split">Split</button>
        </div>
      </div>
      
      <div class="form-group">
        <label>Base Color</label>
        <input type="text" id="hex" value="#FF0000">
      </div>
      
      <div class="color-inputs">
        <div class="color-input">
          <label>R:</label>
          <input type="number" id="r" min="0" max="255">
        </div>
        <div class="color-input">
          <label>G:</label>
          <input type="number" id="g" min="0" max="255">
        </div>
        <div class="color-input">
          <label>B:</label>
          <input type="number" id="b" min="0" max="255">
        </div>
        <div class="color-input">
          <label>H:</label>
          <input type="number" id="h" min="0" max="360">
        </div>
        <div class="color-input">
          <label>S:</label>
          <input type="number" id="s" min="0" max="100">
        </div>
        <div class="color-input">
          <label>L:</label>
          <input type="number" id="l" min="0" max="100">
        </div>
      </div>
      
      <div class="actions">
        <button class="btn" id="copyAll">Copy Color Values</button>
      </div>
    </div>
    
    <div class="content-area">
      <div class="color-wheel-container">
        <canvas id="wheel" width="400" height="400"></canvas>
        <div class="color-marker" id="base-marker" style="background: #FF0000;"></div>
      </div>
      
      <div class="color-palette" id="palette">
        <div class="color-swatch" style="background: #FF0000;">
          <span class="color-swatch-label">Base</span>
          <div class="color-value">#FF0000</div>
        </div>
      </div>
    </div>
  </div>

<script>
const canvas = document.getElementById('wheel');
const ctx = canvas.getContext('2d');
const palette = document.getElementById('palette');
const hexInput = document.getElementById('hex');
const inputs = ['r','g','b','h','s','l'].map(id => document.getElementById(id));
const harmonyBtns = document.querySelectorAll('.harmony-btn');
const baseMarker = document.getElementById('base-marker');
const center = 200;
let base = {h:0,s:100,l:50};
let currentTheory = 'analogous';

// Initialize the color wheel
function drawWheel(){
  for(let i=0;i<360;i++){
    ctx.beginPath();
    ctx.moveTo(center, center);
    ctx.arc(center, center, center, (i-1)*Math.PI/180, i*Math.PI/180);
    ctx.closePath();
    ctx.fillStyle = `hsl(${i},100%,50%)`;
    ctx.fill();
  }
}

// Color conversion functions
function hslToRgb(h,s,l){
  s/=100; l/=100;
  let c=(1-Math.abs(2*l-1))*s, x=c*(1-Math.abs((h/60)%2-1)), m=l-c/2;
  let [r,g,b] = h<60?[c,x,0]:h<120?[x,c,0]:h<180?[0,c,x]:h<240?[0,x,c]:h<300?[x,0,c]:[c,0,0];
  return [Math.round((r+m)*255),Math.round((g+m)*255),Math.round((b+m)*255)];
}

function rgbToHsl(r,g,b){
  r/=255;g/=255;b/=255;
  let max=Math.max(r,g,b),min=Math.min(r,g,b),h,s,l=(max+min)/2,d=max-min;
  if(d===0){h=s=0;} else {
    s=l>0.5?d/(2-max-min):d/(max+min);
    if(max===r) h=((g-b)/d+(g<b?6:0));
    else if(max===g) h=(b-r)/d+2;
    else h=(r-g)/d+4;
    h*=60;
  }
  return [Math.round(h), Math.round(s*100), Math.round(l*100)];
}

function rgbToHex(r,g,b){
  return "#" + [r,g,b].map(c=>c.toString(16).padStart(2,"0")).join("").toUpperCase();
}

function hexToRgb(hex){
  hex = hex.replace('#','');
  const r = parseInt(hex.substring(0,2), 16);
  const g = parseInt(hex.substring(2,4), 16);
  const b = parseInt(hex.substring(4,6), 16);
  return [r,g,b];
}

// Update all input fields based on current color
function updateInputs(){
  const [r,g,b] = hslToRgb(base.h, base.s, base.l);
  const hex = rgbToHex(r,g,b);
  hexInput.value = hex;
  [inputs[0].value, inputs[1].value, inputs[2].value] = [r, g, b];
  [inputs[3].value, inputs[4].value, inputs[5].value] = [base.h, base.s, base.l];
  
  // Update marker position
  const rad = base.h*Math.PI/180;
  const x = center + Math.cos(rad)*180;
  const y = center + Math.sin(rad)*180;
  baseMarker.style.left = x + 'px';
  baseMarker.style.top = y + 'px';
  baseMarker.style.backgroundColor = hex;
}

// Get color harmonies based on selected theory
function getHarmonyColors(h, theory){
  const colors = [];
  
  switch(theory){
    case 'analogous':
      colors.push({h: (h+330)%360, label: 'Analogous 1'});
      colors.push({h: h, label: 'Base'});
      colors.push({h: (h+30)%360, label: 'Analogous 2'});
      break;
      
    case 'monochromatic':
      colors.push({h: h, s: 100, l: 20, label: 'Dark'});
      colors.push({h: h, s: 100, l: 40, label: 'Medium Dark'});
      colors.push({h: h, label: 'Base'});
      colors.push({h: h, s: 80, l: 70, label: 'Light'});
      colors.push({h: h, s: 60, l: 90, label: 'Very Light'});
      break;
      
    case 'triadic':
      colors.push({h: h, label: 'Base'});
      colors.push({h: (h+120)%360, label: 'Triadic 1'});
      colors.push({h: (h+240)%360, label: 'Triadic 2'});
      break;
      
    case 'complementary':
      colors.push({h: h, label: 'Base'});
      colors.push({h: (h+180)%360, label: 'Complement'});
      break;
      
    case 'split':
      colors.push({h: h, label: 'Base'});
      colors.push({h: (h+150)%360, label: 'Split 1'});
      colors.push({h: (h+210)%360, label: 'Split 2'});
      break;
  }
  
  return colors;
}

// Update the color palette display
function updatePalette(){
  palette.innerHTML = '';
  const colors = getHarmonyColors(base.h, currentTheory);
  
  colors.forEach(color => {
    const h = color.h || base.h;
    const s = color.s || base.s;
    const l = color.l || base.l;
    
    const [r,g,b] = hslToRgb(h,s,l);
    const hex = rgbToHex(r,g,b);
    
    const swatch = document.createElement('div');
    swatch.className = 'color-swatch';
    swatch.style.background = hex;
    
    const label = document.createElement('span');
    label.className = 'color-swatch-label';
    label.textContent = color.label;
    
    const value = document.createElement('div');
    value.className = 'color-value';
    value.textContent = hex;
    
    // Make sure text is readable
    const brightness = (r*299 + g*587 + b*114)/1000;
    value.style.color = brightness > 128 ? '#222' : '#fff';
    label.style.color = brightness > 128 ? '#222' : '#fff';
    
    swatch.appendChild(label);
    swatch.appendChild(value);
    
    swatch.onclick = () => {
      navigator.clipboard.writeText(hex);
      const originalText = value.textContent;
      value.textContent = 'COPIED!';
      setTimeout(()=> value.textContent = originalText, 1000);
    };
    
    palette.appendChild(swatch);
  });
}

// Event listeners
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left - center;
  const y = e.clientY - rect.top - center;
  let angle = Math.atan2(y,x)*(180/Math.PI); 
  if(angle<0) angle+=360;
  base.h = Math.round(angle);
  updateInputs(); 
  updatePalette();
});

hexInput.addEventListener('input', ()=>{
  if(/^#?[0-9a-f]{6}$/i.test(hexInput.value.replace('#',''))){
    let hex = hexInput.value;
    if(!hex.startsWith('#')) hex = '#' + hex;
    const [r,g,b] = hexToRgb(hex);
    const [h,s,l] = rgbToHsl(r,g,b);
    base = {h,s,l}; 
    updateInputs(); 
    updatePalette();
  }
});

inputs.forEach(inp=>{
  inp.addEventListener('input', ()=>{
    const r=+inputs[0].value, g=+inputs[1].value, b=+inputs[2].value;
    const h=+inputs[3].value, s=+inputs[4].value, l=+inputs[5].value;
    
    if(!isNaN(r)&&!isNaN(g)&&!isNaN(b) && r>=0&&g>=0&&b>=0&&r<=255&&g<=255&&b<=255){
      const [newH, newS, newL] = rgbToHsl(r,g,b);
      base = {h:newH, s:newS, l:newL};
    } else if(!isNaN(h)&&!isNaN(s)&&!isNaN(l) && h>=0&&s>=0&&l>=0&&h<=360&&s<=100&&l<=100){
      base = {h:h, s:s, l:l};
    }
    
    updateInputs(); 
    updatePalette();
  });
});

harmonyBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    harmonyBtns.forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentTheory = btn.dataset.theory;
    updatePalette();
  });
});

document.getElementById('copyAll').addEventListener('click', ()=>{
  const colors = Array.from(palette.querySelectorAll('.color-value')).map(el => el.textContent);
  navigator.clipboard.writeText(colors.join(', '));
  
  const originalText = this.textContent;
  this.textContent = 'Copied!';
  setTimeout(() => {
    this.textContent = originalText;
  }, 1500);
});

// Initialize
drawWheel(); 
updateInputs(); 
updatePalette();
</script>
</body>
</html>